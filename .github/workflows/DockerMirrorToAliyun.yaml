name: Sync Multi-Arch Docker Images to Alibaba Cloud

on:
  workflow_dispatch:
    inputs:
      force_sync:
        description: 'Force sync all images (ignore cache)'
        type: boolean
        default: false
  schedule:
    - cron: '0 2 * * *'

jobs:
  sync-images:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Login to Alibaba Cloud Container Registry
      uses: docker/login-action@v2
      with:
        registry: registry.cn-hangzhou.aliyuncs.com
        username: ${{ secrets.ALIYUN_USERNAME }}
        password: ${{ secrets.ALIYUN_PASSWORD }}

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq

    - name: Read image list
      id: read_images
      run: |
        if [ -f "images.json" ]; then
          echo "images_config=$(cat images.json | jq -c .)" >> $GITHUB_OUTPUT
          echo "Found $(cat images.json | jq length) images to sync"
        else
          echo "‚ùå images.json not found"
          exit 1
        fi

    - name: Sync images for both architectures
      run: |
        # Convert JSON to bash array
        images_count=$(echo '${{ steps.read_images.outputs.images_config }}' | jq 'length')
        
        for ((i=0; i<images_count; i++)); do
          source_image=$(echo '${{ steps.read_images.outputs.images_config }}' | jq -r ".[$i].source")
          target_image=$(echo '${{ steps.read_images.outputs.images_config }}' | jq -r ".[$i].target")
          
          echo "üîÑ Processing image: $source_image"
          
          # Pull images for both architectures
          echo "üì• Pulling amd64 version..."
          docker pull --platform linux/amd64 $source_image
          
          echo "üì• Pulling arm64 version..."
          docker pull --platform linux/arm64 $source_image
          
          # Create manifest list for multi-arch support
          echo "üì¶ Creating manifest list..."
          docker manifest create $source_image \
            --amend $source_image --platform linux/amd64 \
            --amend $source_image --platform linux/arm64
          
          # Tag and push for each target tag
          tags_count=$(echo '${{ steps.read_images.outputs.images_config }}' | jq ".[$i].tags | length")
          for ((j=0; j<tags_count; j++)); do
            tag=$(echo '${{ steps.read_images.outputs.images_config }}' | jq -r ".[$i].tags[$j]")
            
            # Tag for Alibaba Cloud registry
            target_full_name="registry.cn-hangzhou.aliyuncs.com/${{ secrets.ALIYUN_NAMESPACE }}/$target_image:$tag"
            echo "üè∑Ô∏è  Tagging image as $target_full_name"
            docker tag $source_image $target_full_name
            
            # Push single-arch images
            echo "üì§ Pushing amd64 version..."
            docker push $target_full_name --platform linux/amd64
            
            echo "üì§ Pushing arm64 version..."
            docker push $target_full_name --platform linux/arm64
            
            # Create and push manifest for multi-arch support
            echo "üîÑ Creating multi-arch manifest for $target_full_name"
            docker manifest create $target_full_name \
              --amend $target_full_name --platform linux/amd64 \
              --amend $target_full_name --platform linux/arm64
              
            echo "üì§ Pushing multi-arch manifest..."
            docker manifest push $target_full_name
          done
          
          echo "‚úÖ Completed processing $source_image"
        done

    - name: Cleanup
      if: always()
      run: |
        echo "üßπ Cleaning up Docker images..."
        
        # Remove source images
        images_count=$(echo '${{ steps.read_images.outputs.images_config }}' | jq 'length')
        for ((i=0; i<images_count; i++)); do
          source_image=$(echo '${{ steps.read_images.outputs.images_config }}' | jq -r ".[$i].source")
          docker rmi $source_image || true
          
          target_image=$(echo '${{ steps.read_images.outputs.images_config }}' | jq -r ".[$i].target")
          tags_count=$(echo '${{ steps.read_images.outputs.images_config }}' | jq ".[$i].tags | length")
          for ((j=0; j<tags_count; j++)); do
            tag=$(echo '${{ steps.read_images.outputs.images_config }}' | jq -r ".[$i].tags[$j]")
            target_full_name="registry.cn-hangzhou.aliyuncs.com/${{ secrets.ALIYUN_NAMESPACE }}/$target_image:$tag"
            docker rmi $target_full_name || true
          done
        done
        
        echo "‚úÖ Cleanup completed"

    - name: Send notification on success
      if: success()
      uses: slackapi/slack-github-action@v1.23.0
      with:
        payload: |
          {
            "text": "‚úÖ Multi-arch Docker images sync completed successfully",
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "‚úÖ *Multi-arch Docker images sync completed successfully*\n- Repository: ${{ github.repository }}\n- Architecture: amd64 & arm64\n- Destination: Alibaba Cloud ACR"
                }
              }
            ]
          }
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

    - name: Send notification on failure
      if: failure()
      uses: slackapi/slack-github-action@v1.23.0
      with:
        payload: |
          {
            "text": "‚ùå Multi-arch Docker images sync failed",
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "‚ùå *Multi-arch Docker images sync failed*\n- Repository: ${{ github.repository }}\n- Check the workflow logs for details"
                }
              }
            ]
          }
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
